/*
 * MIT License
 *
 * Copyright (c) 2024 cr4zyengineer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

section .data
    pmm_init_done db "initilized page memory manager\0"
    pmm_init_fail db "failed initilizing memory manager\0"

section .bss
    ppt 255

const ppt_min 0
const ppt_kpages 10

const ppt_in_use 0b00000001

const ppt_error_no_free_page 0x100

_pmm_page_alloc:
    mov r0, ppt                     ; setting r0 to the start of the physical page table
    mov rr, ppt_min                 ; setting rr as the loop director to the ppt start
    ppcnt r3                        ; getting physical page count
.loop:
    ldb r2, r0                      ; getting physical page table entry
    mov r4, r2                      ; moving r2 into r4, because we can just quickly modify and compare on r4 instead of a complex push and pop
    and r4, ppt_in_use              ; masking ppt_in_use flag
    cmp r4, ppt_in_use              ; checking if r2 is ppt_in_use flag
    je .continue                    ; in case physical page is in use we just go further
    or r2, ppt_in_use               ; adding flag to page flags
    stb r0, r2                      ; storing r2 back into ppt
    ret                             ; returning
.continue:
    cmp rr, r3                      ; comparing with maximum ppt
    inc rr, r0                      ; incrementing both
    jlt .loop                       ; if less we jump back to loop start
    mov rr, ppt_error_no_free_page  ; setting return register
    ret

_pmm_page_free:
    ppcnt r1                        ; getting physical page count
    cmp r0, r1                      ; comparing r0 with maximum physical page count
    jgt .end                        ; jumping to end if greater
    add r0, ppt                     ; adding ppt address to r0 and treating r0 as a offset
    ldb r1, r0                      ; loading byte
    and r1, 0b11111110              ; disabling in_use flag
    stb r0, r1                      ; storing byte back into ppt
.end:
    ret

_pmm_init:
    mov r0, 0                       ; preparing for the loop
.loop:
    bl _pmm_page_alloc              ; allocating page
    cmp rr, ppt_error_no_free_page  ; comparing for error
    je .panic                       ; if there is a error we panic
    cmp r0, ppt_kpages              ; checking if we already hit physical page table kernel pages count
    inc r0                          ; incrementing r0
    jlt .loop                       ; if less than kernel pages count
    mov r0, pmm_init_done           ; were done!
    bl _log
    ret
.panic:
    mov r0, pmm_init_fail
    bl _log_err
    hlt