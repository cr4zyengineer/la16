/*
 * MIT License
 *
 * Copyright (c) 2024 cr4zyengineer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/* low level base io symbols */
_getc:
    mov r0, 0b01
    int 0x80
    ret

_putc:
    swpz r1, r0             ; moving r0 into r1 and zeroring r0
    int 0x80                ; interrupt 0x80
    ret

_puts:
    mov r1, r0              ; moving r0 into r1
.loop:
    ldb r0, r1              ; loading value from memory address in r1 into r0
    inc r1                  ; incrementing address
    bl _putc                ; branch link to putc
    cmp r0, '\0'            ; comparing r0 with a null terminator
    jne .loop               ; and back into the old pattern
.end:
    ret

/* printing any unsigned 16bit base you want */
_putbase:
    mov r2, r0              ; r2 = number
    mov r3, r1              ; r3 = base
    push 0
.loop:
    mov r0, r2
    mov r1, r3
    div r0, r1              ; r0 = quotient
    mov r4, r0              ; r4 = quotient (save for next iteration)
    mul r0, r1              ; r0 = quotient * base
    sub r2, r0              ; r2 = remainder (digit)
    cmp r2, 10
    jlt .digit
    add r2, 39              ; 10-35 -> 'a'-'z'
.digit:
    add r2, 48              ; 0-9 -> '0'-'9'
.push:
    push r2
    mov r2, r4
    cmp r2, 0
    jne .loop
.print:
    pop r0
    cmp r0, 0
    bl _putc
    jne .print
.end:
    ret

/*
 * shell helper no.1
 */
_readline:
    jmp .loop
    mov r1, 0                   ; cursor step counter
.loop_delete:
    cmp r1, 0                   ; checking if step counter is at the start
    jle .loop                   ; looping back in that case
    dec r0, r1                  ; decrementing both step and address
    stb r0, '\0'                ; storing null terminator at the deleted position
    call _puts, user_delete     ; clearing latest character in terminal too
.loop:
    call _getc                  ; getting user input
    cmp rr, '\b'                ; checking if user deleted
    je .loop_delete             ; if user deleted we delete it in buffer and line
    cmp rr, 0x7F                ; comparing rr with DEL
    je .loop_delete             ; also jumping there in the case
    cmp rr, '\n'                ; checking if user returned
    call _putc, rr              ; echoing user input back out
    je .end                     ; exiting loop if returned
    stb r0, rr                  ; storing rr into r0 as the address
    inc r0, r1                  ; incrementing r0 as the address
    jmp .loop                   ; reentering input loop
.end:
    stb r0, '\0'                ; null terminating string buffer
    mov rr, r1                  ; telling buffer length
    ret

/*
 * compares two character buffers with eachother, returns 0 if matching
 */
_strcmp:
    mov rr, 1
.loop:
    ldb r2, r0                  ; loading both byte of both buffer addresses
    ldb r3, r1
    cmp r2, r3                  ; comparing for equalness
    jne .end                    ; if they dont match return 1
    cmp r2, '\0'                ; check for null terminator in r2 cuz they match anyways
    je .end_matching            ; they match
    inc r0, r1                  ; incrementing both buffer addresses
    jmp .loop                   ; reentering loop
.end_matching:
    mov rr, 0
.end:
    ret